//
// File generated by HDevelop for HALCON/.NET (C#) Version 12.0.2
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
#endif

    // Procedures 
    /// <summary>
    /// 
    /// </summary>
    /// <param name="ho_Circle"></param>
    /// <param name="hv_Rows"></param>
    /// <param name="hv_Cols"></param>
    /// <param name="hv_ActiveNum"></param>
    /// <param name="hv_ArcType"></param>
    /// <param name="hv_RowCenter"></param>
    /// <param name="hv_ColCenter"></param>
    /// <param name="hv_Radius"></param>
    /// <param name="radiusMinOrMax">false: min, true: max</param>
    public void pts_to_best_circle_using_ellipse(out HObject ho_Circle, HTuple hv_Rows, HTuple hv_Cols,
        HTuple hv_ActiveNum, HTuple hv_ArcType, out HTuple hv_RowCenter, out HTuple hv_ColCenter,
        out HTuple hv_Radius, bool radiusMinOrMax, string algorithm = "fitzgibbon")
    {
        // Local iconic variables 

        HObject ho_Contour = null;

        // Local control variables 

        HTuple hv_Length = null, hv_StartPhi = new HTuple();
        HTuple hv_EndPhi = new HTuple(), hv_PointOrder = new HTuple();
        HTuple hv_Length1 = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Circle);
        HOperatorSet.GenEmptyObj(out ho_Contour);
        hv_RowCenter = 0;
        hv_ColCenter = 0;
        hv_Radius = 0;
        HTuple Radius1 = 0;
        HTuple Radius2 = 0;
        HTuple Phi = 0;

        ho_Circle.Dispose();
        HOperatorSet.GenEmptyObj(out ho_Circle);
        HOperatorSet.TupleLength(hv_Cols, out hv_Length);

        if ((int)((new HTuple(hv_Length.TupleGreaterEqual(hv_ActiveNum))).TupleAnd(new HTuple(hv_ActiveNum.TupleGreater(
            2)))) != 0)
        {

            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Rows, hv_Cols);
            //      HOperatorSet.FitCircleContourXld(ho_Contour, "geotukey", -1, 0, 0, 3, 2, out hv_RowCenter, 
            //          out hv_ColCenter, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);

//            HOperatorSet.WriteContourXldDxf(ho_Contour, @"b:\contour.dxf");


//            HObject ho_UnionContour = null;
//            HOperatorSet.SmoothContoursXld(ho_Contour, out ho_UnionContour, 21);

            // geotukey, fitzgibbon
            HOperatorSet.FitEllipseContourXld(ho_Contour, algorithm, -1, 0, 0, 200, 3, 2.0, out hv_RowCenter,
                out hv_ColCenter, out Phi, out Radius1, out Radius2, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);

            if (!radiusMinOrMax)
            {
                hv_Radius = Radius1 < Radius2 ? Radius1 : Radius2;
            }
            else
            {
                hv_Radius = Radius1 > Radius2 ? Radius1 : Radius2;
            }

            HOperatorSet.TupleLength(hv_StartPhi, out hv_Length1);
            if ((int)(new HTuple(hv_Length1.TupleLess(1))) != 0)
            {
                ho_Contour.Dispose();

                return;
            }
            if ((int)(new HTuple(hv_ArcType.TupleEqual("arc"))) != 0)
            {
                ho_Circle.Dispose();
                HOperatorSet.GenCircleContourXld(out ho_Circle, hv_RowCenter, hv_ColCenter,
                    hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder, 1);
            }
            else
            {
                ho_Circle.Dispose();
                HOperatorSet.GenCircleContourXld(out ho_Circle, hv_RowCenter, hv_ColCenter,
                    hv_Radius, 0, (new HTuple(360)).TupleRad(), hv_PointOrder, 1);
            }
        }

        ho_Contour.Dispose();

        return;
    }


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

